# Name: authenticate
# Group: authenticate
# Description: authenticate INVITE or REGISTER; populates `src_endpoint` based on IP or username
# Parameters:
#   authentication: should be `database`

# ----------
# Tools
# ----------

# Send event in case of forgery / scan attempt / ...
route[notify_authenticate_invalid] {
  xlog("L_DBG","-- notify_authenticate_invalid\n");
  if notify
  $avp(event-names) := null;
  $avp(event-values) := null;
  $avp(event-names) = "endpoint";
  $avp(event-values) = "$json(endpoint_key)";
  $avp(event-names) = "ip";
  $avp(event-values) = "$si";
  raise_event("E_SCRIPT_INVALID",$avp(event-names),$avp(event-values));
  end if notify
}

# Prepare endpoint_key for authentication
route[authenticating_endpoint] {
  $avp(endpoint_key) := null;
  if(!$aU) {
    xlog("L_DBG","-- authenticating_endpoint -- Authorizing source $si missing username\n");
    return(-1);
  }
  if(!$ar) {
    xlog("L_DBG","-- authenticating_endpoint -- Authorizing source $si username $aU missing realm\n");
    return(-1);
  }
  # Configuration-provided, custom endpoint_key fragment of code.
  $var(username) = $aU;
  $var(endpoint_key) = $var(username)+"@"+$ar;

  if fragment__endpoint_key
    ${fragment__endpoint_key}
  end if fragment__endpoint_key

  $avp(endpoint_key) = $var(endpoint_key);

  xlog("L_DBG","-- authenticating_endpoint -- Authorizing source $si using $avp(endpoint_key) \n");
  return(1);
}

# -----------------------------------
# Generic non-REGISTER authentication
# -----------------------------------

macro authenticate

route[authenticate_$1] {
  $var(endpoint) = $si;
  ${get_id "endpoint:"+$si src_endpoint authenticate_continue_$1}
}

route[authenticate_continue_$1] {
  ${save_id src_endpoint}

  if ignore_static_endpoints
  # Only process inbound_sbc
  if($json(src_endpoint/inbound_sbc)) {
    xlog("L_DBG","-- authenticate -- inbound_sbc type $json(src_endpoint/inbound_sbc) at $si\n");
  } else {
    $json(src_endpoint) := '{}';
  }
  end if ignore_static_endpoints

  xlog("L_DBG","-- authenticate -- Testing for sbc type $json(src_endpoint/sbc) at $si\n");
  switch($json(src_endpoint/sbc)) {

    case ${sbc_own_outbound}:
      xlog("L_DBG","-- authenticate -- Not authenticating our own outbound SBC\n");
      break;

    case ${sbc_csr_outbound}:
      xlog("L_DBG","-- authenticate -- Not authenticating a customer outbound SBC\n");
      break;

    default:
      xlog("L_DBG","-- authenticate -- Using socket source IP = $si\n");
      route(authenticate_check_$1); # Authenticate customer
  }

  if( $json(src_endpoint/disabled) == "true" ) {
    send_reply("503", "Disabled");
    exit;
  }
}

# -----------------------------------------------------------------
# UAC Authentication (customer-side, "untrusted")
# -----------------------------------------------------------------

route[authenticate_check_$1] {
  xlog("L_DBG","-- authenticate_check -- Customer device from $si\n");

  # Check whether this is a customer-side trunk (S2S).
  # Do not authenticate if the endpoint is already known.
  if($json(src_endpoint/endpoint)) {
    return;
  }

  if(route(authenticating_endpoint)) {
    ${get_id "endpoint:"+$avp(endpoint_key) src_endpoint authenticate_check_continue_$1}
  } else {
    xlog("L_DBG","-- authenticate_check -- challenging\n");
    proxy_challenge("$var(realm)","0");
    exit;
  }
}

route[authenticate_check_continue_$1] {
  ${save_id src_endpoint}

  # If realm variable is empty, the request's From header's domain is used as realm.
  $var(realm) = "${challenge}";

  if(!$json(src_endpoint/endpoint)) {
    xlog("L_WARN", "WARNING -- authenticate_check -- $si attempts to scan\n");
    route(notify_authenticate_invalid);
    send_reply("403", "Unauthorized");
    exit;
  }

  $var(password) = $json(src_endpoint/password);
  if (!pv_proxy_authorize("$var(realm)")) {
    $var(code) = $retcode;
    xlog("L_DBG","-- proxy_authorize failed: $si ($fu) $var(code)\n");
    proxy_challenge("$var(realm)","0");
    exit;
  }

  if($json(src_endpoint/bypass_from_auth) == "true") {
    xlog("L_DBG","-- authenticate_check -- not checking From username $fu against Authentication ID $aU@$ar\n");
  } else {
    if (!db_check_from()) {
        xlog("L_WARN", "WARNING -- authenticate_check -- $si / $avp(endpoint_key) attempts to authenticate with invalid content\n");
        route(notify_authenticate_invalid);
        send_reply("403", "Unauthorized");
        exit;
    }
  }

  consume_credentials();

  if($json(src_endpoint/require_same_auth) == "true") {
    if( $si == $json(src_endpoint/user_ip) ) {
      xlog("L_DBG","-- authenticate_check -- require_same_auth: $si matches with expected source IP\n");
    } else {
      xlog("L_DBG","-- authenticate_check -- require_same_auth: $si does not match with expected $json(src_endpoint/user_ip)\n");
      route(notify_authenticate_invalid);
      send_reply("403","Incorrect source IP");
      exit;
    }
  }

  xlog("L_DBG","-- authenticate -- Customer device $(json(src_endpoint)).\n");
  route($1_authenticated);
}

# -----------------------------
# Authenticate REGISTER
# -----------------------------

route[authenticate_register_$1] {
  xlog("L_DBG","-- authenticate_register -- Customer device from $si\n");

  if(route(authenticating_endpoint)) {
    ${get_id "endpoint:"+$avp(endpoint_key) src_endpoint authenticate_register_continue_$1}
  } else {
    xlog("L_DBG","-- authenticate_register -- challenging\n");
    www_challenge("$var(realm)","0");
    exit;
  }
}

route[authenticate_register_continue_$1] {
  ${save_id src_endpoint}

  # If realm variable is empty, the request's From header's domain is used as realm.
  $var(realm) = "${challenge}";

  if(!$json(src_endpoint/endpoint)) {
    xlog("L_WARN", "WARNING -- authenticate_register -- $si attempts to scan\n");
    route(notify_authenticate_invalid);
    send_reply("401", "Unauthorized");
    exit;
  }

  $var(password) = $json(src_endpoint/password);
  if (!pv_www_authorize("$var(realm)")) {
    xlog("L_DBG", "-- www_authorize failed: $si ($fu) failed\n");
    www_challenge("$var(realm)","0");
    exit;
  };

  if (!db_check_to()) {
    xlog("L_WARN", "WARNING -- authenticate_register -- $si / $avp(endpoint_key) attempts to register with invalid content\n");
    route(notify_authenticate_invalid);
    send_reply("401", "Unauthorized");
    exit;
  }

  consume_credentials();

  xlog("L_DBG","-- authenticate_register -- Customer device $(json(src_endpoint)).\n");
  route($1_authenticated);
}

end macro authenticate

# Name: register-colocted
# Group: register-handler
# Description: REGISTER handler for a colocated registrar

# -----------------------------------------------------------------
# REGISTER Message Handler: Router and registrar co-located
# -----------------------------------------------------------------

if notify
event_route[E_SCRIPT_REGISTER] {
  $json(event) := '{}';
  fetch_event_params("endpoint=$json(event/endpoint);ip=$json(event/ip)");
  async(rest_post("${notify}/script_register","$json(event)","application/json","$var(body)","$var(type)","$var(code)"),notification_done);
}
end if notify

# Router and registrar are co-located

  # REGISTER messages are processed locally.
define do_not_forward_register

${authenticate register}

route[register_handler]
{
  xlog("L_DBG","-- register_handler -- REGISTER Message Handler from $source_uri\n");

  if min_expires
    $var(expires) = 0;
    if( is_present_hf("Expires") && $(hdr(Expires){s.int}) > 0 ) {
      $var(expires) = $(hdr(Expires){s.int});
    }
    if( $ct.fields(expires) && $(ct.fields(expires){s.int}) > 0 ) {
      $var(expires) = $(ct.fields(expires){s.int});
    }
    # var(expires) might be 0 if no Expires was found,
    # or if Expires was 0, which means un-register.
    if( $var(expires) > 0 && $var(expires) < ${min_expires} ) {
      append_hf("Min-Expires: ${min_expires}");
      send_reply("423","Interval Too Brief");
      exit;
    }

  end if min_expires

  if has_register_nat
    route(register_nat);
  end if has_register_nat

  route(authenticate_register);
}

route[register_authenticated] {

  if register_check_ip
    if( $json(src_endpoint/check_ip) == "true" ) {
      if( $si != $json(src_endpoint/user_ip) ) {

        if notify
          # Cache the last IP seen for each endpoint, to reduce the number of events sent upstream.
          $avp(last_source) := null;
          if(!cache_fetch("local","register $json(src_endpoint/endpoint)",$avp(last_source)) || $avp(last_source) != $si) {
            $avp(event-names) := null;
            $avp(event-values) := null;
            $avp(event-names) = "endpoint";
            $avp(event-values) = "$json(src_endpoint/endpoint)";
            $avp(event-names) = "ip";
            $avp(event-values) = "$si";
            raise_event("E_SCRIPT_REGISTER",$avp(event-names),$avp(event-values));
            cache_store("local","register $json(src_endpoint/endpoint)","$si",${cache_timeout});
          }
        end if notify

        send_reply("403","Invalid Source");
        exit;
      }
    }
  end if register_check_ip

  if has_usrloc
    if( !save("${usrloc_table}","${usrloc_flags}","$var(aor)") ) {
      xlog("L_ERR", "ERROR -- register_handler -- could not save location $si ($fu).\n");
      send_reply("500", "Could not save location");
      exit;
    }
  end if has_usrloc
  exit;
}

# Co-located

macro simple_lookup
  # Does a lookup of $var(aor), modulo any local transformations.
  xlog("L_DBG","-- simple_lookup -- aor = $var(aor) --\n");

  # Configuration-provided, custom aor fragment of code.
  # Maps an AOR before lookup from the one found in the Request to the one found in the database.
  if fragment__aor
    ${fragment__aor}
  end if fragment__aor

  xlog("L_DBG","-- simple_lookup -- lookup $var(aor) --\n");

  if has_usrloc

    # async( lookup("${usrloc_table}","","$var(aor)"), $1 );
    lookup("${usrloc_table}","","$var(aor)");
    route($1);

  end if has_usrloc
  exit;
end macro simple_lookup
